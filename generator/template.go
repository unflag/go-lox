//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
)

const (
	generatedFileName = "../ast_type_gen.go"
)

func main() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Panicf("%+v", err)
	}

	dirs := strings.Split(cwd, "/")
	cwd = dirs[len(dirs)-1]
	fileName := os.Getenv("GOFILE")

	type (
		TypeDesc struct {
			Returns bool
			Types   map[string]map[string]any
		}
		ASTDesc struct {
			SourceFileName string
			AST            map[string]TypeDesc
		}
	)

	var buf bytes.Buffer
	if err = astTemplate.Execute(&buf, ASTDesc{
		SourceFileName: fmt.Sprintf("%s/%s", cwd, fileName),
		AST: map[string]TypeDesc{
			"Expr": {
				Returns: true,
				Types: map[string]map[string]any{
					"Binary": map[string]any{
						"Left":     "Expr",
						"Operator": "*Token",
						"Right":    "Expr",
					},
					"Grouping": map[string]any{
						"Expression": "Expr",
					},
					"Literal": map[string]any{
						"Value": "any",
					},
					"Unary": map[string]any{
						"Operator": "*Token",
						"Right":    "Expr",
					},
					"Variable": map[string]any{
						"Name": "*Token",
					},
					"Assign": map[string]any{
						"Name":  "*Token",
						"Value": "Expr",
					},
				},
			},
			"Stmt": {
				Returns: false,
				Types: map[string]map[string]any{
					"Expression": map[string]any{
						"Expression": "Expr",
					},
					"Print": map[string]any{
						"Expression": "Expr",
					},
					"Var": map[string]any{
						"Name":        "*Token",
						"Initializer": "Expr",
					},
					"Block": map[string]any{
						"Statements": "[]Stmt",
					},
				},
			},
		},
	}); err != nil {
		log.Panicf("%+v", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Panicf("%+v\n%s", err, string(buf.Bytes()))
	}

	if err := os.WriteFile(generatedFileName, formatted, 0644); err != nil {
		log.Panicf("%+v", err)
	}
}

var astTemplate = template.Must(template.New("").Parse(
	`// Code generated by go generate; DO NOT EDIT.
// Source: {{ .SourceFileName }}

package main

{{ range $class, $ast := .AST }}
type {{ $class }} interface {}

type {{ $class }}Visitor[T any] interface {
    {{ range $typeName, $_ := $ast.Types -}}
	Visit{{ $typeName }}{{ $class }}(e *{{ $typeName }}){{ if $ast.Returns }} T{{ end }}
    {{ end -}}
}

func Accept{{ $class }}Visitor[T any](a {{ $class }}, v {{ $class }}Visitor[T]){{ if $ast.Returns }} T{{ end }} {
    switch a := a.(type) {
    {{ range $typeName, $_ := $ast.Types -}}
    case *{{ $typeName }}:
	    {{ if $ast.Returns }}return {{ end }} v.Visit{{ $typeName }}{{ $class }}(a)
    {{ end -}}
    default:
    }
    {{ if $ast.Returns }}return any(nil).(T){{ end -}}
}

{{ range $typeName, $typeDefinition := $ast.Types -}}
type {{ $typeName }} struct {
  {{- range $field, $type := $typeDefinition }}
  {{ $field }} {{ $type }}
  {{- end }}
}

{{ end -}}

{{ end -}}
`))
